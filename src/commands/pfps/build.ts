import { Args, Flags } from '@oclif/core';
import { BaseCommand } from '../../base/BaseCommand.js';
import { create } from 'kubo-rpc-client';
import path from 'node:path';
import fs, { readFileSync } from 'node:fs';
import { SingleBar } from 'cli-progress';
import { Pfp, PfpManifest } from '../../types/pfps.js';
import { getTemplate } from '../../services/template-service.js';
import { AssetSchema } from '../../types/index.js';
import { generateMintExcelFileWithContent } from '../../services/mint-service.js';
import { makeSpinner } from '../../utils/tty-utils.js';

export default class BuildPfpsCommand extends BaseCommand {
  static examples = [
    {
      command:
        '<%= config.bin %> <%= command.id %> ./pfps-folder -c alpacaworls -t 11324 -a alpacaworlds -n "My NFT" -r',
      description:
        'Uploads all the pfps in the ./pfpfs folder to ipfs, creates the mint file using template 11324 and collection alpacaworls.',
    },
  ];
  static description = 'Uploads all the pfps generated by the generate command to ipfs and creates the mint file.';

  static args = {
    input: Args.directory({
      description: 'Directory where the pfps are saved.',
      required: true,
    }),
  };

  static flags = {
    randomize: Flags.boolean({
      char: 'r',
      description: 'Randomizes the pfps before creting the mint file.',
      default: false,
    }),
    template: Flags.string({
      char: 't',
      description: 'The template where the NFTs will be minted.',
      required: true,
    }),
    collection: Flags.string({
      char: 'c',
      description: 'The collection to use for the mint file.',
      required: true,
    }),
    account: Flags.string({
      char: 'a',
      description: 'The account who will receive the pfps.',
    }),
    name: Flags.string({
      char: 'n',
      description: 'The name to prepend in the NFT name.',
      required: true,
    }),
    nameDigits: Flags.integer({
      description: 'The number of digits in the number in the NFT name.',
      default: 4,
    }),
  };

  public async run(): Promise<void> {
    const { args, flags } = await this.parse(BuildPfpsCommand);

    const { input } = args;

    const ipfs = create({
      url: 'https://ipfs.neftyblocks.io:443/api/v0',
      headers: {
        referer: 'https://neftyblocks.com',
      },
    });

    const manifestPath = path.join(input, 'manifest.json');
    const imagePath = path.join(input, 'images');
    if (!fs.existsSync(manifestPath)) {
      throw new Error('No manifest.json file found. Run the generate command first.');
    }

    if (!fs.existsSync(imagePath)) {
      throw new Error('No images folder found. Run the generate command first.');
    }

    const pfpManifest: PfpManifest = JSON.parse(readFileSync(manifestPath).toString());
    if (pfpManifest.pfps.length === 0) {
      throw new Error('No pfps found. Run the generate command first.');
    }

    const files = pfpManifest.pfps.map((pfp: Pfp) => {
      const fileName = pfp.dna + '.png';
      const filePath = path.join(imagePath, fileName);
      if (!fs.existsSync(filePath)) {
        throw new Error('No pfp image found for ' + pfp.dna);
      }
      return {
        dna: pfp.dna,
        path: fileName,
        content: fs.readFileSync(filePath),
      };
    });

    const filesToUpload = files.filter((file) => !pfpManifest.uploads[file.dna]);
    if (filesToUpload.length > 0) {
      const progressBar = new SingleBar({
        format: 'Uploading images | {bar} | {percentage}% | {value}/{total} pfps | ETA: {eta_formatted}',
        barCompleteChar: '\u2588',
        barIncompleteChar: '\u2591',
        hideCursor: true,
      });

      progressBar.start(files.length, 0);

      for (const file of files) {
        const result = await ipfs.add(file);
        pfpManifest.uploads[file.dna] = result.cid.toString();
        fs.writeFileSync(manifestPath, JSON.stringify(pfpManifest, null, 2));
        progressBar.increment();
      }
      progressBar.stop();
    }

    const { randomize, template, collection, account } = flags;

    const config = await this.getCliConfig();

    if (randomize) {
      pfpManifest.pfps.sort(() => Math.random() - 0.5);
    }

    const spinner = makeSpinner('Getting template').start();

    const templateObject = await getTemplate(collection, template, config);
    const namedPfs = pfpManifest.pfps.map((pfp: Pfp, index: number) => {
      const formattedNumber = String(index + 1).padStart(flags.nameDigits, '0');
      const name = `${flags.name} #${formattedNumber}`;
      return {
        ...pfp,
        attributes: {
          ...pfp.attributes,
          name,
          img: pfpManifest.uploads[pfp.dna],
        },
      };
    });

    spinner.succeed('Template loaded');

    const content = {
      [templateObject.template_id]: namedPfs.map((pfp: { dna: string; attributes: Record<string, any> }) => {
        if (!pfp.attributes.img) {
          throw new Error(`Missing image for ${pfp.dna}`);
        }

        if (!pfp.attributes.name) {
          throw new Error(`Missing name for ${pfp.dna}`);
        }

        return pfp.attributes;
      }),
    };

    const schema: AssetSchema = {
      ...templateObject.schema,
      name: templateObject.schema.schema_name,
      collectionName: collection,
    };

    const mintFilePath = path.join(input, 'mint-pfps.xlsx');
    spinner.start('Generating mint file');
    await generateMintExcelFileWithContent([schema], [templateObject], account, 1, mintFilePath, content);

    pfpManifest.collectionName = collection;
    fs.writeFileSync(manifestPath, JSON.stringify(pfpManifest, null, 2));

    spinner.succeed('Mint file generated');
  }
}
